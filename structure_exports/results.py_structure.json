{
  "project_info": {
    "name": "results.py",
    "path": "/Users/espensele/Desktop/Master/MasterOppg/Homomorphic-Neural-Cryptography/results.py",
    "generated_at": "2025-01-23T16:28:07.668711",
    "total_files": 1
  },
  "structure": {
    "results.py": {
      "type": "file",
      "info": {
        "mime_type": "text/x-python",
        "extension": ".py"
      }
    }
  },
  "files": [
    {
      "path": "results.py",
      "content": "import os\nimport numpy as np\nfrom neural_network.networks import create_networks\nfrom data_utils.analyse_cipher import plot_std_and_mean, probabilistic_encryption_analysis\nfrom data_utils.accuracy import decryption_accurancy, HO_accuracy\nfrom data_utils.sequential_arithmetic_operations import sequential_arithmetic_operations\nfrom typing import List\n\ndef print_results(results: dict):\n    \"\"\"\n    Print the results of a dictionary\n\n    Args:\n        results: The dictionary of results\n    \"\"\"\n    for curve in results:\n        print(f\"Curve: {curve}\")\n        for rate in results[curve]:\n            print(f\"Rate {rate}: {results[curve][rate]}\")\n        print()\n\ndef get_accuracy(batch_size: int, nonce_bits: int, dropout_rates: List[float], curves: List[str]):\n    \"\"\"\n    Prints the decryption accuracy of Bob and Eve, including the accuracy of the HO model\n    \n    Args:\n        batch_size: Number of samples in the dataset\n        nonce_bits: The number of bits in the nonce\n        dropout_rates: The dropout rates\n        curves: The curves\n    \"\"\"\n    p1_batch = np.load(f\"plaintext/p1-{batch_size}.npy\")\n    p2_batch = np.load(f\"plaintext/p2-{batch_size}.npy\")\n    results = {}\n    addition = []\n    mulitplication = []\n    p1_decrypted = []\n    p2_decrypted = []\n    HO_addition = []\n    HO_multiplication = []\n    for curve in curves:\n        results[curve] = {}\n        public_arr = np.load(f\"key/public_key-{curve}-{batch_size}.npy\")\n        private_arr = np.load(f\"key/private_key-{curve}-{batch_size}.npy\")\n        nonce = np.random.rand(batch_size, nonce_bits)\n        for rate in dropout_rates:\n            results[curve][rate] = {}\n            alice, bob, HO_model_addition, eve, _, _, _, _, _, _, c3_bits, _, HO_model_multiplication = create_networks(public_arr.shape[1], private_arr.shape[1], rate)\n            path_name = f\"ma-rate-{rate}-curve-{curve}\"\n            weights_path = f'weights/weights-{path_name}'\n            if not os.path.exists(weights_path):\n                continue\n            HO_model_addition.load_weights(f'{weights_path}/addition_weights.h5')\n            HO_model_multiplication.load_weights(f'{weights_path}/multiplication_weights.h5')\n            alice.load_weights(f'{weights_path}/alice_weights.h5')\n            bob.load_weights(f'{weights_path}/bob_weights.h5')\n            eve.load_weights(f'{weights_path}/eve_weights.h5')\n            cipher1, cipher2 = alice.predict([public_arr, p1_batch, p2_batch, nonce])\n            operation_a = np.zeros((batch_size, c3_bits))\n            operation_m = np.ones((batch_size, c3_bits))\n            cipher3_a = HO_model_addition.predict([operation_a, cipher1, cipher2])\n            cipher3_m = HO_model_multiplication.predict([operation_m, cipher1, cipher2])\n            # Calculate HO model's accuracy\n            HO_addition.append(HO_accuracy(cipher3_a, cipher1+cipher2))\n            HO_multiplication.append(HO_accuracy(cipher3_m, cipher1*cipher2))\n            # Calculate Bob's decryption accuracy\n            results[curve][rate]['p1+p2'] = decryption_accurancy(bob, cipher3_a, private_arr, nonce, p1_batch+p2_batch)\n            results[curve][rate]['p1*p2'] = decryption_accurancy(bob, cipher3_m, private_arr, nonce, p1_batch*p2_batch)\n            results[curve][rate]['p1'] = decryption_accurancy(bob, cipher1, private_arr, nonce, p1_batch)\n            results[curve][rate]['p2'] = decryption_accurancy(bob, cipher2, private_arr, nonce, p2_batch)\n            # Calculate Eve's decryption accuracy\n            addition.append(decryption_accurancy(eve, cipher3_a, public_arr, nonce, p1_batch+p2_batch))\n            mulitplication.append(decryption_accurancy(eve, cipher3_m, public_arr, nonce, p1_batch*p2_batch))\n            p1_decrypted.append(decryption_accurancy(eve, cipher1, public_arr, nonce, p1_batch))\n            p2_decrypted.append(decryption_accurancy(eve, cipher2, public_arr, nonce, p2_batch))\n\n    print(\"Bob's decryption accuracy: \")\n    print_results(results)\n\n    print(f\"Eve's average decryption accuracy: \")\n    print(f\"Addition: {np.round(np.mean(addition), 2)}\")\n    print(f\"Multiplication: {np.round(np.mean(mulitplication), 2)}\")\n    print(f\"P1: {np.round(np.mean(p1_decrypted), 2)}\")\n    print(f\"P2: {np.round(np.mean(p2_decrypted), 2)}\\n\")\n\n    print(f\"HO Addition model's average accuracy: {np.round(np.mean(HO_addition), 2)}\")\n    print(f\"HO Multiplication model's average accuracy: {np.round(np.mean(HO_multiplication), 2)} \\n\")\n\ndef get_std_results(rates: List[float], curves: List[str], batch_size: int = 1):\n    \"\"\"\n    Get the standard deviation results of the probabilistic encryption\n    \n    Args:\n        rates: The dropout rates\n        curves: The curves\n        batch_size: Number of samples in the dataset\n    \"\"\"\n    results = {}\n    for curve in curves:\n        results[curve] = {}\n        for rate in rates:\n            results[curve][rate] = {}\n            std = probabilistic_encryption_analysis(rate, curve, batch_size)\n            results[curve][rate]['std_std'] = round(np.std(std), 4)\n            results[curve][rate]['mean_std'] = round(np.mean(std), 4)\n        plot_std_and_mean(dropout_rates, curve, batch_size)\n    print(\"Standard deviation results: \")\n    print_results(results)\n\ndef get_decryption_accuracy_on_sequential_operations(rate: float, batch_size: int, curve: str):\n    \"\"\"\n    Get Bob's decryption accuracy on sequential operations performed by the HO networks\n    \n    Args:\n        rate: The dropout rate\n        batch_size: The batch size\n        curve: The curve\n        \n    Returns:\n        The decryption accuracy of Bob\n    \"\"\"\n    p5, p7, p8, p9 = sequential_arithmetic_operations(rate, batch_size, curve)\n    print(f\"Decryption accuracy P1+P2+P3: {p5}\")\n    print(f\"Decryption accuracy P1*P2*P3: {p7}\")\n    print(f\"Decryption accuracy (P1+P2)*P3: {p8}\")\n    print(f\"Decryption accuracy P1*P2+P3: {p9}\")\n\n\nif __name__ == \"__main__\":\n    batch_size = 448\n    nonce_bits = 64\n    dropout_rates = [0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7]\n    curves = [\"secp224r1\", \"secp256k1\", \"secp256r1\", \"secp384r1\", \"secp521r1\"]\n    get_accuracy(batch_size, nonce_bits, dropout_rates, curves)\n    get_std_results(dropout_rates, curves)\n    get_decryption_accuracy_on_sequential_operations(0.2, batch_size, \"secp256r1\")",
      "info": {
        "mime_type": "text/x-python",
        "extension": ".py"
      },
    }
  ]
}