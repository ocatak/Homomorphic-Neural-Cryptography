{
  "project_info": {
    "name": "key",
    "path": "/Users/espensele/Desktop/Master/MasterOppg/Homomorphic-Neural-Cryptography/key",
    "total_files": 1
  },
  "structure": {
    "EllipticCurve.py": {
      "type": "file",
      "info": {
        "size": 3190,
        "last_modified": "2025-01-23T15:54:28.998689",
        "mime_type": "text/x-python",
        "extension": ".py"
      }
    }
  },
  "files": [
    {
      "path": "EllipticCurve.py",
      "content": "from cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePrivateKey, EllipticCurvePublicKey\nfrom typing import Tuple\nimport numpy as np\nfrom numpy.typing import NDArray\nfrom argparse import ArgumentParser\n\ndef set_curve(curve_name: str) -> ec.EllipticCurve:\n    \"\"\"Sets the elliptic curve based on the given name.\n\n    Args:\n        curve_name: The name of the curve to set.\n\n    Returns:\n        An instance of an elliptic curve class.\n\n    Raises:\n        ValueError: If an invalid curve name is provided.\n    \"\"\"\n    if curve_name == \"secp224r1\":\n        return ec.SECP224R1()\n    elif curve_name == \"secp256k1\":\n        return ec.SECP256K1()\n    elif curve_name == \"secp256r1\":\n        return ec.SECP256R1()\n    elif curve_name == \"secp384r1\":\n        return ec.SECP384R1()\n    elif curve_name == \"secp521r1\":\n        return ec.SECP521R1()\n    else:\n        raise ValueError(\"Invalid curve name\")\n\n\ndef get_key_shape(curve: ec.EllipticCurve) -> Tuple[int, int]:\n    \"\"\"Gets the public key and private key shape.\n\n    Args:\n        curve: The elliptic curve.\n\n    Returns:\n        A tuple of the private key shape and public key shape.\n    \"\"\"\n    private_key = ec.generate_private_key(\n            curve, default_backend())\n    public_key = private_key.public_key()\n    pr, pu = convert_key_to_pem(private_key, public_key)\n    return pr.size, pu.size\n\n\ndef generate_key_pair(batch_size: int, curve: ec.EllipticCurve) -> Tuple[NDArray[np.object_], NDArray[np.object_]]:\n    \"\"\"Generates a batch of private and public keys.\n    \n    Args:\n        batch_size: The number of keys to generate.\n        curve: The elliptic curve.\n        \n    Returns:\n        A tuple of private keys and public keys, each a numpy array of numpy arrays containing float64 elements.\n    \"\"\"\n    size = get_key_shape(curve)\n    pr_arr = np.empty((batch_size, size[0]))\n    pu_arr = np.empty((batch_size, size[1]))\n    for i in range(batch_size):\n        private_key = ec.generate_private_key(\n            curve, default_backend())\n        # Derive the associated public key\n        public_key = private_key.public_key()\n        pr_arr[i], pu_arr[i] = convert_key_to_pem(private_key, public_key)\n    return pr_arr, pu_arr\n\n\ndef convert_key_to_pem(private_key: EllipticCurvePrivateKey, public_key: EllipticCurvePublicKey) -> Tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"Convert keys to PEM format.\n\n    Args:\n        private_key: The private key.\n        public_key: The public key.\n    \n    Returns:\n        A tuple containing the bit representations of the private and public keys as numpy arrays of numpy arrays containing float64 elements.\n    \"\"\"\n    private_pem = private_key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.TraditionalOpenSSL,\n        encryption_algorithm=serialization.NoEncryption()\n    ).decode()\n    public_pem = public_key.public_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PublicFormat.SubjectPublicKeyInfo\n    ).decode()\n    return convert_key_to_bit(private_pem), convert_key_to_bit(public_pem)\n\n\ndef convert_key_to_bit(pem: str) -> NDArray[np.int64]:\n    \"\"\" Converts a PEM-encoded key string to its bit representation as a numpy array.\n    \n    Args:\n        pem: The PEM-encoded key string.\n    \n    Returns:\n        A numpy array of int64 elements representing the key in bits.\n    \"\"\"\n    # Convert PEM string to a bit string\n    bits = ''.join([format(ord(c), '08b') for c in pem])\n    arr = np.array([int(bit) for bit in bits])\n    return arr\n\nif __name__ == \"__main__\":\n    parser = ArgumentParser()\n    parser.add_argument('-batch', type=int, default=1, help='Batch size')\n    parser.add_argument('-curve', type=str, default=\"secp224r1\", help='Elliptic curve name')\n    args = parser.parse_args()\n    curve = set_curve(args.curve)\n    private_key, public_key = generate_key_pair(args.batch, curve)\n    np.save(f\"key/private_key-{args.curve}-{args.batch}.npy\", private_key)\n    np.save(f\"key/public_key-{args.curve}-{args.batch}.npy\", public_key)",
      "info": {
        "mime_type": "text/x-python",
        "extension": ".py"
      }
    }
  ]
}